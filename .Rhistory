#' @references
#' Dixit, Vaidehi, and Ryan Martin. "Revisiting consistency of a
#' recursive estimator of mixing distributions."
#' arXiv preprint arXiv:2110.02465 (2021).
#'@export
monotone = function(X, nperm = 25){
n = length(X)
U = seq(10^-5, max(X), length.out = 101)
f0 = dunif(U, min = min(U), max = max(U))
Xsup = seq(10^-20, 10, length.out = 101)
f = pr(X = X, d = d.mon, U = U, f0 = f0, nperm = nperm)
m = mixture_density(f = f$f, U = U, d = d.mon, Xsup = Xsup)
return(list(Xsup = Xsup, m = m))
}
m = monotone(X)
truth = 2*dnorm(m$Xsup)
plot(m$Xsup, truth, type = "l")
lines(m$Xsup, m$m, col = "red")
n = 200
X = abs(rnorm(n))
m = monotone(X)
truth = 2*dnorm(m$Xsup)
plot(m$Xsup, truth, type = "l")
lines(m$Xsup, m$m, col = "red")
# To calculate KL divergence
KL_divg = function(est, truth, sup){
# truth = truth/int(truth, sup)
# est = est/int(est, sup)
num = (log(truth/est))*truth
num[is.infinite(num)] = 0
num[is.na(num)] = 0
return(int(num, sup))
}
n = length(X)
U = seq(10^-5, max(X), length.out = 101)
max(X)
U = seq(10^-5, max(X), length.out = 101)
f0 = dunif(U, min = min(U), max = max(U))
Xsup = seq(10^-20, 10, length.out = 101)
f = pr(X = X, d = d.mon, U = U, f0 = f0, nperm = nperm)
nperm = 25
f = pr(X = X, d = d.mon, U = U, f0 = f0, nperm = nperm)
#'
d.mon = function(x,u){
dunif(x, min = 0, max = u)
}
m = mixture_density(f = f$f, U = U, d = d.mon, Xsup = Xsup)
truth = 2*dnorm(Xsup)
KL_divg(est = m, truth = truth, sup = Xsup)
View(KL_divg)
Xsup = seq(10^-20, max(X), length.out = 101)
truth = 2*dnorm(m$Xsup)
truth = 2*dnorm(Xsup)
m = mixture_density(f = f$f, U = U, d = d.mon, Xsup = Xsup)
KL_divg(est = m, truth = truth, sup = Xsup)
n = length(X)
U = seq(10^-5, max(X), length.out = 101)
f0 = dunif(U, min = min(U), max = max(U))
Xsup = seq(10^-20, max(X), length.out = 101)
f = pr(X = X, d = d.mon, U = U, f0 = f0, nperm = nperm)
m = mixture_density(f = f$f, U = U, d = d.mon, Xsup = Xsup)
max(X)
truth = 2*dnorm(Xsup)
KL_divg(est = m, truth = truth, sup = Xsup)
f$f
int(f$f,U)
int(m,Xsup)
is.numeric(c(1,2))
as.double(c(1,2))
devtools::load_all()
rm(list = c("d.mon", "monotone"))
devtools::document()
mixture_density()
mixture_density
n=20
n=200
X=abs(rnorm(n))
m=monotone(X)
truth = 2*dnorm(m$Xsup)
plot(m$Xsup, truth, type = "l")
lines(m$Xsup, m$m, col = "red")
?monotone
devtools::document()
?monotone
?pr
devtools::document()
?pr
devtools::document()
?pr
devtools::document()
?pr
devtools::document()
?pr
devtools::document()
?pr
devtools::document()
?pr
devtools::document()
?pr
?mixture_density
methods(plot)
?plot.function
plot(qnorm)
plot(pr)
plot(f)
plot.pr(f)
devtools::load_all()
plot.pr(f)
plot(f)
plot.pr = function(f){
plot(U, f$f, type = "l")
}
plot(f$f)
U = seq(0, 1, length.out = 101)
f0 = dunif(U, min = 0, max = 1)
u = rbeta(n = 1000, 2, 10)
x = rnorm(n = 1000, mean = u, sd = 0.1)
ans1 = pr(X = x, d = dnorm, U = U, f0 = f0, sd = 0.1)
plot.pr = function(f){
plot(U, f$f, type = "l")
}
plot(ans1)
plot.pr = function(obj){
plot(U, obj$f, type = "l", main = "YAYY")
}
plot(ans1)
?plot.function
plot.pr = function(obj){
curve(obj$f, from = 0, to = 10, type = "l", main = "YAYY")
}
plot(ans1)
attributes(ans1)
plot(ans1, from=0, to=10)
x = 1:8
attr(x,"dim") <- c(2, 4)
x
attributes(x)
class(pr)
#############################################################################################################################
#'@export
pr <- function(X, d, U, f0, w, nperm = 1, perm = NULL,...) {
X = as.matrix(X)
U = as.matrix(U)
n <- nrow(X)
t <- nrow(U)
du <- ncol(U)
if(missing(f0)) f0 <- 1 + 0 * U[,1]
if(missing(w)) w <- function(i) 1 / (i + 1)^{0.67}
N <- nperm
if(N == 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n}
else if(N > 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n
for(j in 2:N) perm[,j] <- sample(n)
}
f.avg = 0 * f0
L.avg = 0
if(du==1){
f0 = f0 / int(f0, U)
for(j in 1:N) {
f = f0
L = 0
x <- X[perm[,j],]
for(i in 1:n) {
num <- d(x[i], U,...) * f
den <- int(num, U)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else if(du==2){
f0 = f0 / simp.int2(U[,2], U[,1], matrix(f0, t, t, byrow=TRUE))
U.l = as.matrix(expand.grid(U[,1],U[,2]))
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
for(i in 1:n){
num = d(x[i,], U.l,...) * f
f_matrix = matrix(num, nrow = t, ncol = t, byrow=TRUE)
den = simp.int2(U[,2], U[,1], f_matrix)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else {
D.avg = 0 * f0
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
D = 1
for(i in 1:n) {
num <- d(x[i,], U,...) * f
den <- (1/t)*sum(d(x[i,], U,...)*D)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
D = D*(1 + w(i)*(d(x[i,], U,...)/den - 1))
}
# Add D.avg
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
D.avg <- (j - 1) * D.avg / j + D / j
}
ans = list(f=f.avg, L=-L.avg, D = D.avg)
class(ans) = "pr"
return(ans)
}
}
plot.pr = function(obj){
plot(U, obj$f, type = "l", main = "YAYY")
}
x = rnorm(n = 1000, mean = u, sd = 0.1)
ans1 = pr(X = x, d = dnorm, U = U, f0 = f0, sd = 0.1)
plot(ans1)
#############################################################################################################################
#'@export
pr <- function(X, d, U, f0, w, nperm = 1, perm = NULL,...) {
X = as.matrix(X)
U = as.matrix(U)
n <- nrow(X)
t <- nrow(U)
du <- ncol(U)
if(missing(f0)) f0 <- 1 + 0 * U[,1]
if(missing(w)) w <- function(i) 1 / (i + 1)^{0.67}
N <- nperm
if(N == 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n}
else if(N > 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n
for(j in 2:N) perm[,j] <- sample(n)
}
f.avg = 0 * f0
L.avg = 0
if(du==1){
f0 = f0 / int(f0, U)
for(j in 1:N) {
f = f0
L = 0
x <- X[perm[,j],]
for(i in 1:n) {
num <- d(x[i], U,...) * f
den <- int(num, U)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(U = U, f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else if(du==2){
f0 = f0 / simp.int2(U[,2], U[,1], matrix(f0, t, t, byrow=TRUE))
U.l = as.matrix(expand.grid(U[,1],U[,2]))
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
for(i in 1:n){
num = d(x[i,], U.l,...) * f
f_matrix = matrix(num, nrow = t, ncol = t, byrow=TRUE)
den = simp.int2(U[,2], U[,1], f_matrix)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(U = U, f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else {
D.avg = 0 * f0
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
D = 1
for(i in 1:n) {
num <- d(x[i,], U,...) * f
den <- (1/t)*sum(d(x[i,], U,...)*D)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
D = D*(1 + w(i)*(d(x[i,], U,...)/den - 1))
}
# Add D.avg
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
D.avg <- (j - 1) * D.avg / j + D / j
}
ans = list(U = U, f=f.avg, L=-L.avg, D = D.avg)
class(ans) = "pr"
return(ans)
}
}
plot.pr = function(obj){
U = as.matrix(obj$U)
du = ncol(U)
if(du==1){
plot(U, obj$f, xlab = "U", ylab = "f", type = "l", main = "Estimated Mixing density")
}
else if(du==2) {
f.matrix = matrix(obj$f, nrow(U), nrow(U), byrow = TRUE)
gcf_grid(U[,2], U[,1], f.matrix)
}
else {
print("Plot yet to be decided")
}
}
plot(ans1)
ans1 = pr(X = x, d = dnorm, U = U, f0 = f0, sd = 0.1)
plot(ans1)
lines(U, dbeta(U, 2,10), col = "red")
U = cbind(seq(0, 1, length.out = 101), seq(10^-5, 1, length.out = 101))
f0 = rep(1, 101*101)
d2 = function(x,u){
return(dnorm(x, mean = u[,1], sd = u[,2]))
}
u = cbind(rbeta(n = 2000, 2, 10), rbeta(n = 2000, 4, 4))
x = rnorm(n = 2000, mean = u[,1], sd = u[,2])
ans2 = pr(X = x, d = d2, U = U, f0 = f0)
library(ContourFunctions)
plot(ans2)
plot.pr = function(obj){
U = as.matrix(obj$U)
du = ncol(U)
if(du==1){
plot(U, obj$f, xlab = "U", ylab = "f", type = "l", main = "Estimated Mixing density")
}
else if(du==2) {
f.matrix = matrix(obj$f, nrow(U), nrow(U), byrow = TRUE)
gcf_grid(U[,2], U[,1], f.matrix, main = "")
}
else {
print("Plot yet to be decided")
}
}
plot(ans2)
plot.pr = function(obj){
U = as.matrix(obj$U)
du = ncol(U)
if(du==1){
plot(U, obj$f, xlab = "U", ylab = "f", type = "l", main = "Estimated Mixing density")
}
else if(du==2) {
f.matrix = matrix(obj$f, nrow(U), nrow(U), byrow = TRUE)
gcf_grid(U[,2], U[,1], f.matrix, mainminmax = FALSE)
}
else {
print("Plot yet to be decided")
}
}
plot(ans2)
plot.pr = function(obj){
U = as.matrix(obj$U)
du = ncol(U)
if(du==1){
plot(U, obj$f, xlab = "U", ylab = "f", type = "l", main = "Estimated Mixing density")
}
else if(du==2) {
f.matrix = matrix(obj$f, nrow(U), nrow(U), byrow = TRUE)
gcf_grid(U[,2], U[,1], f.matrix, mainminmax = FALSE, MAIN = "yay?")
}
else {
print("Plot yet to be decided")
}
}
plot(ans2)
plot.pr = function(obj){
U = as.matrix(obj$U)
du = ncol(U)
if(du==1){
plot(U, obj$f, xlab = "U", ylab = "f", type = "l", main = "Estimated Mixing density")
}
else if(du==2) {
f.matrix = matrix(obj$f, nrow(U), nrow(U), byrow = TRUE)
gcf_grid(U[,2], U[,1], f.matrix, mainminmax = FALSE, color.palette = function(x) rev(gray((1:x)/x)), bar = TRUE)
}
else {
print("Plot yet to be decided")
}
}
plot(ans2)
U.l = as.matrix(expand.grid(U[,1],U[,2]))
f.truth = dbeta(U.l[, 1], 2, 10) * dbeta(U.l[, 2], 4, 4)
gcf_grid(U[,2], U[,1], matrix(f.truth, 101, 101, byrow = TRUE))
library(sn)
d3 = function(x,u,...){
ans = numeric(length(u[,1]))
for(i in 1:length(u[,1])){
ans[i] = dsn(x, xi = u[i,1], omega = u[i,2], alpha = u[i,3])
}
return(ans)
}
#############################################################################################################################
#'@export
pr <- function(X, d, U, f0, w, nperm = 1, perm = NULL,...) {
X = as.matrix(X)
U = as.matrix(U)
n <- nrow(X)
t <- nrow(U)
du <- ncol(U)
if(missing(f0)) f0 <- 1 + 0 * U[,1]
if(missing(w)) w <- function(i) 1 / (i + 1)^{0.67}
N <- nperm
if(N == 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n}
else if(N > 1 && is.null(perm)) {
perm <- matrix(0, n, N)
perm[,1] <- 1:n
for(j in 2:N) perm[,j] <- sample(n)
}
f.avg = 0 * f0
L.avg = 0
if(du==1){
f0 = f0 / int(f0, U)
for(j in 1:N) {
f = f0
L = 0
x <- X[perm[,j],]
for(i in 1:n) {
num <- d(x[i], U,...) * f
den <- int(num, U)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(U = U, f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else if(du==2){
f0 = f0 / simp.int2(U[,2], U[,1], matrix(f0, t, t, byrow=TRUE))
U.l = as.matrix(expand.grid(U[,1],U[,2]))
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
for(i in 1:n){
num = d(x[i,], U.l,...) * f
f_matrix = matrix(num, nrow = t, ncol = t, byrow=TRUE)
den = simp.int2(U[,2], U[,1], f_matrix)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
}
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
}
ans = list(U = U, f=f.avg, L=-L.avg)
class(ans) = "pr"
return(ans)
}
else {
D.avg = 0 * f0
for(j in 1:N) {
f = f0
L = 0
x <- as.matrix(X[perm[,j], ])
D = 1
for(i in 1:n) {
num <- d(x[i,], U,...) * f
den <- (1/t)*sum(d(x[i,], U,...)*D)
L <- L + log(den)
f <- (1 - w(i)) * f + w(i) * num / den
D = D*(1 + w(i)*(d(x[i,], U,...)/den - 1))
}
# Add D.avg
f.avg <- (j - 1) * f.avg / j + f / j
L.avg <- (j - 1) * L.avg / j + L / j
D.avg <- (j - 1) * D.avg / j + D / j
}
ans = list(U = U, f=f.avg, L=-L.avg, D = D.avg)
class(ans) = "pr"
return(ans)
}
}
t = 3000
U = cbind(runif(t, min = 0, max = 1), runif(t, min = 0, max = 1), runif(t, min = -4, max = 4))
ans3 = pr(X = x, d = d3, U = U)
plot(ans3)
devtools::load_all()
read.dcf(system.file("DESCRIPTION", package = "ContourFunctions", mustWork = TRUE))
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
rm(list = c("plot.pr", "pr"))
devtools:document()
devtools::document()
devtools::load_all()
